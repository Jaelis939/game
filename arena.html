<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>RealmZ: The Codebound Arena | Battle</title>
    <style>
        /* === GLOBAL RESET === */
        * { margin: 0; padding: 0; box-sizing: border-box; }
        body { 
            font-family: 'Press Start 2P', cursive; 
            background: #0f0c29; 
            color: #fff; 
            overflow: hidden;
            height: 100vh;
            cursor: url('data:image/svg+xml;utf8,<svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24"><circle cx="12" cy="12" r="10" fill="none" stroke="%23ff5555" stroke-width="2"/></svg>'), auto;
        }

        /* === GAME CONTAINERS === */
        .arena-container {
            position: relative;
            width: 100%;
            height: 100vh;
            overflow: hidden;
            background: 
                radial-gradient(circle at 20% 30%, rgba(106, 76, 147, 0.1) 0%, transparent 25%),
                radial-gradient(circle at 80% 70%, rgba(157, 78, 221, 0.1) 0%, transparent 25%),
                url('data:image/svg+xml;utf8,<svg xmlns="http://www.w3.org/2000/svg" width="100" height="100" viewBox="0 0 100 100"><rect width="100" height="100" fill="%230f0c29"/><path d="M0,0 L100,100 M100,0 L0,100" stroke="%23333" stroke-width="1"/></svg>');
        }

        #game-canvas {
            position: absolute;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            z-index: 1;
        }

        /* === CUSTOM UI ELEMENTS === */
        .ui-overlay {
            position: absolute;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            pointer-events: none;
            z-index: 10;
        }

        /* -- Health Bar -- */
        .health-container {
            position: absolute;
            top: 20px;
            left: 20px;
            width: 250px;
            background: rgba(0, 0, 0, 0.7);
            border: 3px solid #6a4c93;
            border-radius: 10px;
            padding: 5px;
            display: flex;
            align-items: center;
        }

        .health-bar {
            height: 30px;
            background: linear-gradient(to right, #ff0000, #ff5555);
            border-radius: 5px;
            transition: width 0.3s;
            position: relative;
            overflow: hidden;
        }

        .health-bar::after {
            content: "";
            position: absolute;
            top: 0;
            left: 0;
            right: 0;
            bottom: 0;
            background: linear-gradient(90deg, transparent, rgba(255, 255, 255, 0.3), transparent);
            animation: shine 2s infinite;
        }

        @keyframes shine {
            0% { transform: translateX(-100%); }
            100% { transform: translateX(100%); }
        }

        .health-text {
            position: absolute;
            left: 10px;
            color: white;
            font-size: 0.8rem;
            text-shadow: 0 0 5px black;
            z-index: 2;
        }

        /* -- Wave Counter -- */
        .wave-display {
            position: absolute;
            top: 20px;
            left: 50%;
            transform: translateX(-50%);
            background: rgba(0, 0, 0, 0.7);
            border: 3px solid #6a4c93;
            border-radius: 10px;
            padding: 0.8rem 1.5rem;
            font-size: 0.9rem;
            color: #9d4edd;
            text-align: center;
        }

        /* -- Gold/Score Display -- */
        .resource-display {
            position: absolute;
            top: 20px;
            right: 20px;
            display: flex;
            gap: 10px;
        }

        .resource-box {
            background: rgba(0, 0, 0, 0.7);
            border: 3px solid #6a4c93;
            border-radius: 10px;
            padding: 0.5rem 1rem;
            display: flex;
            align-items: center;
            gap: 5px;
        }

        .gold-icon, .score-icon {
            width: 20px;
            height: 20px;
            background: gold;
            border-radius: 50%;
            display: flex;
            justify-content: center;
            align-items: center;
            font-size: 0.7rem;
        }

        .score-icon {
            background: #9d4edd;
        }

        /* -- Ability Bar -- */
        .ability-bar {
            position: absolute;
            bottom: 20px;
            left: 50%;
            transform: translateX(-50%);
            display: flex;
            gap: 10px;
            z-index: 11;
        }

        .ability-slot {
            width: 60px;
            height: 60px;
            background: rgba(0, 0, 0, 0.7);
            border: 3px solid #6a4c93;
            border-radius: 10px;
            display: flex;
            flex-direction: column;
            align-items: center;
            justify-content: center;
            cursor: pointer;
            pointer-events: all;
            transition: all 0.2s;
        }

        .ability-slot:hover {
            border-color: #9d4edd;
            transform: scale(1.1);
        }

        .ability-icon {
            font-size: 1.5rem;
            margin-bottom: 5px;
        }

        .ability-key {
            font-size: 0.7rem;
            color: #aaa;
        }

        .cooldown-overlay {
            position: absolute;
            bottom: 0;
            left: 0;
            right: 0;
            background: rgba(0, 0, 0, 0.7);
            border-radius: 0 0 5px 5px;
            overflow: hidden;
        }

        .cooldown-fill {
            height: 100%;
            background: rgba(106, 76, 147, 0.5);
            transition: height 0.1s;
        }

        /* -- Custom Cursors -- */
        .attack-cursor {
            cursor: url('data:image/svg+xml;utf8,<svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24"><path fill="%23ff5555" d="M12,2L4,12L8,12L8,22L16,22L16,12L20,12Z"/></svg>'), auto;
        }

        /* === GAME MENUS === */
        .pause-menu {
            position: absolute;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            background: rgba(0, 0, 0, 0.9);
            border: 4px solid #6a4c93;
            border-radius: 10px;
            padding: 2rem;
            text-align: center;
            z-index: 20;
            display: none;
            width: 80%;
            max-width: 500px;
        }

        .menu-title {
            font-size: 2rem;
            color: #9d4edd;
            margin-bottom: 1.5rem;
            text-shadow: 0 0 10px #9d4edd;
        }

        .menu-btn {
            background: linear-gradient(45deg, #6a4c93, #9d4edd);
            border: none;
            color: white;
            padding: 1rem 2rem;
            margin: 0.5rem;
            font-family: inherit;
            font-size: 1rem;
            cursor: pointer;
            border-radius: 5px;
            transition: all 0.3s;
            width: 100%;
        }

        .menu-btn:hover {
            transform: scale(1.05);
            box-shadow: 0 0 15px #9d4edd;
        }

        /* === DAMAGE NUMBERS === */
        .damage-text {
            position: absolute;
            color: #ff5555;
            font-size: 1.5rem;
            font-weight: bold;
            text-shadow: 0 0 5px black;
            animation: float-up 1s forwards, fade-out 1s forwards;
            pointer-events: none;
            z-index: 5;
        }

        .crit-text {
            color: #ff0000;
            font-size: 2rem;
            animation: float-up 1.5s forwards, fade-out 1.5s forwards, shake 0.5s;
        }

        @keyframes float-up {
            0% { transform: translateY(0); }
            100% { transform: translateY(-100px); }
        }

        @keyframes fade-out {
            0% { opacity: 1; }
            100% { opacity: 0; }
        }

        @keyframes shake {
            0%, 100% { transform: translateX(0); }
            25% { transform: translateX(-5px); }
            75% { transform: translateX(5px); }
        }

        /* === BOSS HEALTH BAR === */
        .boss-health-container {
            position: absolute;
            top: 80px;
            left: 50%;
            transform: translateX(-50%);
            width: 80%;
            max-width: 600px;
            background: rgba(0, 0, 0, 0.7);
            border: 3px solid #ff5555;
            border-radius: 10px;
            padding: 5px;
            display: none;
            z-index: 10;
        }

        .boss-name {
            position: absolute;
            top: -20px;
            left: 10px;
            color: #ff5555;
            font-size: 0.8rem;
            text-shadow: 0 0 5px black;
        }

        .boss-health-bar {
            height: 20px;
            background: linear-gradient(to right, #ff0000, #ff5555);
            border-radius: 5px;
            transition: width 0.3s;
        }

        /* === WAVE TRANSITION === */
        .wave-transition {
            position: absolute;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background: rgba(0, 0, 0, 0.8);
            display: flex;
            justify-content: center;
            align-items: center;
            z-index: 30;
            opacity: 0;
            pointer-events: none;
            transition: opacity 0.5s;
        }

        .wave-text {
            font-size: 3rem;
            color: #9d4edd;
            text-shadow: 0 0 20px #9d4edd;
            animation: pulse 2s infinite;
        }

        @keyframes pulse {
            0%, 100% { transform: scale(1); opacity: 1; }
            50% { transform: scale(1.1); opacity: 0.7; }
        }

        /* Add this at the end of your <style> block for mobile improvements */
        @media (max-width: 700px) {
    body, .arena-container {
        min-height: 100vh;
        height: 100vh;
        padding: 0;
        overflow: hidden;
    }
    #game-canvas {
        width: 100vw !important;
        height: 100vh !important;
        min-width: 100vw;
        min-height: 100vh;
        max-width: 100vw;
        max-height: 100vh;
        display: block;
        background: #0f0c29;
    }
    .health-container,
    .resource-display,
    .wave-display,
    .boss-health-container {
        left: 0 !important;
        right: 0 !important;
        margin: 0 auto !important;
        width: 95vw !important;
        min-width: 0 !important;
        max-width: 99vw !important;
        font-size: 0.9rem !important;
        padding: 0.4rem 0.7rem !important;
    }
    .health-bar, .boss-health-bar {
        height: 18px !important;
        font-size: 0.8rem !important;
    }
    .health-text {
        font-size: 0.7rem !important;
        left: 6px !important;
    }
    .ability-bar {
        bottom: 12px !important;
        left: 50% !important;
        transform: translateX(-50%) !important;
        gap: 7px !important;
        width: 98vw !important;
        max-width: 340px !important;
        min-width: 0 !important;
        justify-content: center;
    }
    .ability-slot {
        width: 48px !important;
        height: 48px !important;
        border-width: 2px !important;
        border-radius: 8px !important;
    }
    .ability-icon {
        font-size: 1.1rem !important;
        margin-bottom: 2px !important;
    }
    .ability-key {
        font-size: 0.65rem !important;
    }
    .pause-menu {
        width: 96vw !important;
        max-width: 99vw !important;
        padding: 1.2rem 0.5rem !important;
        left: 50% !important;
        top: 50% !important;
        transform: translate(-50%, -50%) !important;
    }
    .menu-title {
        font-size: 1.2rem !important;
        margin-bottom: 1rem !important;
    }
    .menu-btn {
        font-size: 1rem !important;
        padding: 0.8rem 0.5rem !important;
        margin: 0.4rem 0 !important;
        border-radius: 7px !important;
    }
    .wave-transition .wave-text {
        font-size: 1.5rem !important;
    }
    .damage-text, .crit-text {
        font-size: 1.1rem !important;
    }
}
    </style>
</head>
<body>
    <div class="arena-container">
        <canvas id="game-canvas"></canvas>
        
        <!-- UI OVERLAY -->
        <div class="ui-overlay">
            <!-- Health Bar -->
            <div class="health-container">
                <div class="health-bar" id="health-bar" style="width: 100%">
                    <div class="health-text" id="health-text">100/100</div>
                </div>
            </div>

            <!-- Wave Counter -->
            <div class="wave-display" id="wave-display">
                WAVE: 1 | ENEMIES: 0
            </div>

            <!-- Resources -->
            <div class="resource-display">
                <div class="resource-box">
                    <div class="gold-icon">G</div>
                    <span id="gold-display">0</span>
                </div>
                <div class="resource-box">
                    <div class="score-icon">S</div>
                    <span id="score-display">0</span>
                </div>
            </div>

            <!-- Ability Bar -->
            <div class="ability-bar">
                <div class="ability-slot" id="ability-1">
                    <div class="ability-icon">‚öîÔ∏è</div>
                    <div class="ability-key">Q</div>
                    <div class="cooldown-overlay">
                        <div class="cooldown-fill" id="cooldown-1"></div>
                    </div>
                </div>
                <div class="ability-slot" id="ability-2">
                    <div class="ability-icon">üõ°Ô∏è</div>
                    <div class="ability-key">E</div>
                    <div class="cooldown-overlay">
                        <div class="cooldown-fill" id="cooldown-2"></div>
                    </div>
                </div>
                <div class="ability-slot" id="ability-3">
                    <div class="ability-icon">üî•</div>
                    <div class="ability-key">R</div>
                    <div class="cooldown-overlay">
                        <div class="cooldown-fill" id="cooldown-3"></div>
                    </div>
                </div>
            </div>

            <!-- Boss Health -->
            <div class="boss-health-container" id="boss-health">
                <div class="boss-name" id="boss-name">BOSS NAME</div>
                <div class="boss-health-bar" id="boss-health-bar" style="width: 100%"></div>
            </div>
        </div>

        <!-- Wave Transition -->
        <div class="wave-transition" id="wave-transition">
            <div class="wave-text" id="wave-text">WAVE 1</div>
        </div>

        <!-- Pause Menu -->
        <div class="pause-menu" id="pause-menu">
            <h2 class="menu-title">ARENA PAUSED</h2>
            <button class="menu-btn" id="resume-btn">RESUME</button>
            <button class="menu-btn" id="restart-btn">RESTART</button>
            <button class="menu-btn" id="quit-btn">QUIT TO HUB</button>
        </div>

        <div id="arena" style="position:relative;width:100%;height:100%;"></div>
    </div>

    <div id="arena-status" style="position:fixed;top:20px;right:30px;z-index:1000;background:#181028;color:#fff;padding:8px 18px;border-radius:8px;font-weight:bold;box-shadow:0 0 10px #9d4edd88;">Offline Mode</div>
<div id="arena-players"></div>
<style>
#arena-players { position:relative; width:100vw; height:80vh; }
.arena-player {
  position:absolute; width:60px; height:80px; display:flex; flex-direction:column; align-items:center; transition: left 0.1s, top 0.1s;
}
.player-name {
  font-size: 0.9rem;
  margin-bottom: 2px;
  color: #9d4edd;
  text-shadow: 0 0 4px #000;
}
.player-model {
  width: 48px; height: 48px; background: #222; border-radius: 50%; border: 2px solid #9d4edd;
}
</style>

    <script src="items.js"></script>
    <script>
        // ===== GAME STATE ===== //
        const currentUser = localStorage.getItem('realmz-current-user');
        const users = JSON.parse(localStorage.getItem('realmz-users')) || {};

        if (!currentUser || !users[currentUser]) {
            window.location.href = 'index.html';
        }

        const user = users[currentUser];

        // ====== PLAYTIME TRACKING ======
        let playtimeStart = Date.now();
        let playtimeInterval = setInterval(() => {
            if (!user.playtime) user.playtime = 0;
            user.playtime += 1; // +1 second
            users[currentUser] = user;
            localStorage.setItem('realmz-users', JSON.stringify(users));
        }, 1000);

        // ===== CANVAS SETUP ===== //
        const canvas = document.getElementById('game-canvas');
        const ctx = canvas.getContext('2d');
        canvas.width = window.innerWidth;
        canvas.height = window.innerHeight;

        // ===== GAME VARIABLES ===== //
        const level = user.level || 1;
        let baseAttack = 10 + (level - 1) * 2;
        let baseMaxHp = 100 + (level - 1) * 10;
        let baseDefense = 5 + Math.floor((level - 1) / 2);
        let baseCrit = 5 + (level - 1) * 0.5;

        // Weapon bonuses
        if (user.equipped?.weapon) {
            const weapon = (user.inventoryData || []).find(i => i.id === user.equipped.weapon && i.type === 'weapon');
            if (weapon) {
                baseAttack += weapon.attack || 0;
                baseCrit += weapon.crit || 0;
            }
        }

        // Armor bonuses
        if (user.equipped?.armor) {
            const armor = (user.inventoryData || []).find(i => i.id === user.equipped.armor && i.type === 'armor');
            if (armor) {
                baseDefense += armor.defense || 0;
                baseMaxHp += armor.hp || 0;
            }
        }

        // Accessory/special bonuses
        if (user.equipped?.accessory) {
            const accessory = (user.inventoryData || []).find(i => i.id === user.equipped.accessory && i.type === 'accessory');
            if (accessory) {
                if (accessory.id === 'crit_charm') baseCrit += 15;
                // Add more logic for other accessories here
            }
        }

        let player = {
            x: canvas.width / 2,
            y: canvas.height / 2,
            radius: 20,
            speed: 5,
            health: baseMaxHp,
            maxHealth: baseMaxHp,
            attackDamage: baseAttack,
            defense: baseDefense,
            critChance: baseCrit,
            attackCooldown: 0,
            attackRange: 50,
            color: '#9d4edd',
            isDodging: false,
            dodgeCooldown: 0,
            abilities: {
                whirlwind: { cooldown: 0, maxCooldown: 300 },
                shield: { cooldown: 0, maxCooldown: 180 },
                fireball: { cooldown: 0, maxCooldown: 600 }
            }
        };

        // === NOW apply skill bonuses ===
        const skills = user.skills || {};
        function skillLevel(id) { return skills[id] || 0; }
        player.attackDamage += Math.floor(player.attackDamage * 0.05 * skillLevel('power_strike'));
        player.defense += Math.floor(player.defense * 0.06 * skillLevel('iron_skin'));
        player.maxHealth += 20 * skillLevel('vitality');
        player.critChance += 2 * skillLevel('critical_focus');
        player.attackDamage += Math.floor(player.attackDamage * 0.07 * skillLevel('arcane_mastery'));
        player.speed += 0.3 * skillLevel('swiftness');
        player.goldBonus = 0.04 * skillLevel('lucky_charm');
        player.healOnWin = 0.02 * skillLevel('battle_healer');

        // Enemies
        let enemies = [];
        let goldDrops = [];
        let keys = {};
        let mouse = { x: 0, y: 0, isDown: false };
        let gameTime = 0;
        let score = 0;
        let collectedGold = 0;
        let isGameOver = false;
        let isPaused = false;
        let currentWave = 1;
        let enemiesInWave = 0;
        let enemiesKilled = 0;
        let bossActive = false;

        // ===== SOUND EFFECTS ===== //
        const soundEffects = {
            attack: () => playSound(440, 'square', 0.1),
            hit: () => playSound(220, 'sine', 0.1),
            crit: () => playSound(880, 'sine', 0.2),
            dodge: () => playSound(1320, 'triangle', 0.2),
            ability: () => playSound(660, 'sawtooth', 0.3),
            gold: () => playSound(1760, 'triangle', 0.2)
        };

        function playSound(frequency, type, duration) {
            try {
                const audioContext = new (window.AudioContext || window.webkitAudioContext)();
                const oscillator = audioContext.createOscillator();
                const gainNode = audioContext.createGain();
                oscillator.type = type;
                oscillator.frequency.value = frequency;
                oscillator.connect(gainNode);
                gainNode.connect(audioContext.destination);
                gainNode.gain.exponentialRampToValueAtTime(0.0001, audioContext.currentTime + duration);
                oscillator.start();
                oscillator.stop(audioContext.currentTime + duration);
            } catch (e) {
                console.log("Audio error:", e);
            }
        }

        // ===== PLAYER CONTROLS ===== //
        window.addEventListener('keydown', (e) => {
            keys[e.key.toLowerCase()] = true;

            // Pause game
            if (e.key === 'Escape') {
                togglePause();
            }

            // Abilities
            if (e.key === 'q') useAbility('whirlwind');
            if (e.key === 'e') useAbility('shield');
            if (e.key === 'r') useAbility('fireball');
            if (e.key === ' ') dodgeRoll();
        });

        window.addEventListener('keyup', (e) => {
            keys[e.key.toLowerCase()] = false;
        });

        canvas.addEventListener('mousemove', (e) => {
            mouse.x = e.clientX;
            mouse.y = e.clientY;
        });

        canvas.addEventListener('mousedown', () => {
            mouse.isDown = true;
            document.body.classList.add('attack-cursor');
        });

        canvas.addEventListener('mouseup', () => {
            mouse.isDown = false;
            document.body.classList.remove('attack-cursor');
        });

        // === MOBILE TOUCH CONTROLS ===
        let touchStart = null;
        let touchMoved = false;

        // Move player with swipe
        canvas.addEventListener('touchstart', function(e) {
            if (e.touches.length === 1) {
                touchStart = { x: e.touches[0].clientX, y: e.touches[0].clientY };
                touchMoved = false;
            }
        }, { passive: false });

        canvas.addEventListener('touchmove', function(e) {
            if (touchStart && e.touches.length === 1) {
                touchMoved = true;
                const dx = e.touches[0].clientX - touchStart.x;
                const dy = e.touches[0].clientY - touchStart.y;
                // Move player in swipe direction
                player.x += dx * 0.15;
                player.y += dy * 0.15;
                // Keep player in bounds
                player.x = Math.max(player.radius, Math.min(canvas.width - player.radius, player.x));
                player.y = Math.max(player.radius, Math.min(canvas.height - player.radius, player.y));
                touchStart = { x: e.touches[0].clientX, y: e.touches[0].clientY };
            }
        }, { passive: false });

        canvas.addEventListener('touchend', function(e) {
            // Tap = attack, double tap = dodge
            if (!touchMoved && e.changedTouches.length === 1) {
                if (!canvas._lastTap || Date.now() - canvas._lastTap > 350) {
                    // Single tap: attack
                    mouse.isDown = true;
                    setTimeout(() => { mouse.isDown = false; }, 120);
                    canvas._lastTap = Date.now();
                } else {
                    // Double tap: dodge
                    dodgeRoll();
                    canvas._lastTap = 0;
                }
            }
            touchStart = null;
            touchMoved = false;
        }, { passive: false });

        // Ability buttons for mobile
        function createMobileAbilityButtons() {
            if (document.getElementById('mobile-abilities')) return;
            const bar = document.createElement('div');
            bar.id = 'mobile-abilities';
            bar.style.position = 'fixed';
            bar.style.bottom = '70px';
            bar.style.right = '10px';
            bar.style.zIndex = 100;
            bar.style.display = 'flex';
            bar.style.flexDirection = 'column';
            bar.style.gap = '10px';
            ['whirlwind','shield','fireball'].forEach((ability, idx) => {
                const btn = document.createElement('button');
                btn.textContent = ['‚öîÔ∏è','üõ°Ô∏è','üî•'][idx];
                btn.style.fontSize = '1.5rem';
                btn.style.width = '48px';
                btn.style.height = '48px';
                btn.style.borderRadius = '50%';
                btn.style.border = '2px solid #9d4edd';
                btn.style.background = '#1a102a';
                btn.style.color = '#ffd700';
                btn.style.boxShadow = '0 0 10px #9d4edd55';
                btn.style.cursor = 'pointer';
                btn.style.opacity = '0.92';
                btn.style.transition = 'transform 0.1s';
                btn.onclick = () => useAbility(ability);
                bar.appendChild(btn);
            });
            document.body.appendChild(bar);
        }
        if (window.innerWidth <= 700) createMobileAbilityButtons();
        window.addEventListener('resize', () => {
            if (window.innerWidth <= 700) createMobileAbilityButtons();
            else {
                const bar = document.getElementById('mobile-abilities');
                if (bar) bar.remove();
            }
        });

        // ===== GAME FUNCTIONS ===== //
        function spawnEnemy(type = 'normal') {
            const side = Math.floor(Math.random() * 4);
            let x, y;

            switch (side) {
                case 0: x = -30; y = Math.random() * canvas.height; break;
                case 1: x = canvas.width + 30; y = Math.random() * canvas.height; break;
                case 2: x = Math.random() * canvas.width; y = -30; break;
                case 3: x = Math.random() * canvas.width; y = canvas.height + 30; break;
            }

            const enemyTypes = {
                normal: {
                    radius: 20,
                    speed: 1.5,
                    health: 30,
                    damage: 10,
                    color: '#6a4c93',
                    gold: 10,
                    score: 20
                },
                elite: {
                    radius: 25,
                    speed: 2,
                    health: 50,
                    damage: 15,
                    color: '#ff5555',
                    gold: 25,
                    score: 50
                },
                boss: {
                    radius: 40,
                    speed: 1,
                    health: 200,
                    damage: 25,
                    color: '#ff0000',
                    gold: 100,
                    score: 200,
                    name: 'The Bloodthirster'
                }
            };

            const enemy = {
                x,
                y,
                ...enemyTypes[type],
                type,
                attackCooldown: 0,
                originalSpeed: enemyTypes[type].speed
            };

            enemies.push(enemy);
            enemiesInWave++;

            if (type === 'boss') {
                bossActive = true;
                document.getElementById('boss-health').style.display = 'block';
                document.getElementById('boss-name').textContent = enemy.name;
                document.getElementById('boss-health-bar').style.width = '100%';
            }
        }

        function spawnGold(x, y, amount) {
            goldDrops.push({
                x,
                y,
                radius: 10,
                amount,
                color: 'gold',
                collected: false,
                sparkleTimer: 0
            });
        }

        function createDamageText(x, y, amount, isCritical = false) {
            const text = document.createElement('div');
            text.className = `damage-text${isCritical ? ' crit-text' : ''}`;
            text.textContent = `-${amount}`;
            text.style.left = `${x}px`;
            text.style.top = `${y}px`;

            document.querySelector('.ui-overlay').appendChild(text);

            setTimeout(() => {
                text.remove();
            }, isCritical ? 1500 : 1000);
        }

        function dodgeRoll() {
            if (player.dodgeCooldown <= 0 && !player.isDodging) {
                player.isDodging = true;
                player.dodgeCooldown = 120;
                player.speed *= 3;
                soundEffects.dodge();

                setTimeout(() => {
                    player.isDodging = false;
                    player.speed = 5;
                }, 300);
            }
        }

        function useAbility(ability) {
            if (player.abilities[ability].cooldown <= 0 && !isPaused) {
                player.abilities[ability].cooldown = player.abilities[ability].maxCooldown;
                soundEffects.ability();

                switch (ability) {
                    case 'whirlwind':
                        // Damage all enemies in radius
                        enemies.forEach(enemy => {
                            const dist = Math.hypot(player.x - enemy.x, player.y - enemy.y);
                            if (dist < 150) {
                                enemy.health -= player.attackDamage * 1.5;
                                createDamageText(enemy.x, enemy.y - 30, Math.floor(player.attackDamage * 1.5));
                            }
                        });
                        break;
                        
                    case 'shield':
                        // Temporary invincibility
                        player.maxHealth += 50;
                        setTimeout(() => {
                            player.maxHealth = 100;
                            if (player.health > player.maxHealth) player.health = player.maxHealth;
                        }, 5000);
                        break;
                        
                    case 'fireball':
                        // Shoot a fire projectile
                        // (Implementation would go here)
                        break;
                }
            }
        }

        function startWave(waveNumber) {
            currentWave = waveNumber;
            enemiesKilled = 0;
            enemiesInWave = 0;
            
            // Show wave transition
            const waveTransition = document.getElementById('wave-transition');
            const waveText = document.getElementById('wave-text');
            waveText.textContent = `WAVE ${waveNumber}`;
            waveTransition.style.opacity = '1';
            
            setTimeout(() => {
                waveTransition.style.opacity = '0';
                
                // Spawn enemies based on wave
                let normalCount = 3 + Math.floor(waveNumber * 1.5);
                let eliteCount = Math.floor(waveNumber / 3);
                
                for (let i = 0; i < normalCount; i++) {
                    setTimeout(() => spawnEnemy('normal'), i * 500);
                }
                
                for (let i = 0; i < eliteCount; i++) {
                    setTimeout(() => spawnEnemy('elite'), normalCount * 500 + i * 800);
                }
                
                // Every 5 waves, spawn a boss
                if (waveNumber % 5 === 0) {
                    setTimeout(() => spawnEnemy('boss'), (normalCount + eliteCount) * 500 + 1000);
                }
                
            }, 2000);
        }

        function togglePause() {
            isPaused = !isPaused;
            document.getElementById('pause-menu').style.display = isPaused ? 'block' : 'none';
        }

        function gameOver(isVictory) {
            isGameOver = true;
            
            // Update user stats
            user.gold += collectedGold;
            if (isVictory) {
                user.wins += 1;
            }
            // Save playtime one last time
            if (!user.playtime) user.playtime = 0;
            user.playtime += Math.floor((Date.now() - playtimeStart) / 1000);
            users[currentUser] = user;
            localStorage.setItem('realmz-users', JSON.stringify(users));
            
            clearInterval(playtimeInterval);
            
            // Show result screen (would be implemented)
            setTimeout(() => {
                window.location.href = 'hub.html';
            }, 3000);
        }

        // When quitting or reloading, save playtime
        window.addEventListener('beforeunload', () => {
            if (!user.playtime) user.playtime = 0;
            user.playtime += Math.floor((Date.now() - playtimeStart) / 1000);
            users[currentUser] = user;
            localStorage.setItem('realmz-users', JSON.stringify(users));
            clearInterval(playtimeInterval);
        });
        
        // ===== GAME LOOP ===== //
        function gameLoop() {
            if (isGameOver || isPaused) return;
            
            // Clear canvas
            ctx.clearRect(0, 0, canvas.width, canvas.height);
            
            // Update game time
            gameTime++;
            
            // Update cooldowns
            player.attackCooldown--;
            player.dodgeCooldown--;
            
            for (const ability in player.abilities) {
                if (player.abilities[ability].cooldown > 0) {
                    player.abilities[ability].cooldown--;
                    
                    // Update UI
                    const cooldownElement = document.getElementById(`cooldown-${ability === 'whirlwind' ? 1 : ability === 'shield' ? 2 : 3}`);
                    const percent = (player.abilities[ability].cooldown / player.abilities[ability].maxCooldown) * 100;
                    cooldownElement.style.height = `${percent}%`;
                }
            }
            
            // Player movement
            let moveX = 0;
            let moveY = 0;
            
            if (keys['w'] || keys['arrowup']) moveY -= player.speed;
            if (keys['s'] || keys['arrowdown']) moveY += player.speed;
            if (keys['a'] || keys['arrowleft']) moveX -= player.speed;
            if (keys['d'] || keys['arrowright']) moveX += player.speed;
            
            // Normalize diagonal movement
            if (moveX !== 0 && moveY !== 0) {
                moveX *= 0.7071;
                moveY *= 0.7071;
            }
            
            player.x += moveX;
            player.y += moveY;
            
            // Keep player in bounds
            player.x = Math.max(player.radius, Math.min(canvas.width - player.radius, player.x));
            player.y = Math.max(player.radius, Math.min(canvas.height - player.radius, player.y));
            
            // Player attack
            if (player.attackCooldown <= 0 && mouse.isDown) {
                let attacked = false;
                
                for (let i = 0; i < enemies.length; i++) {
                    const enemy = enemies[i];
                    const dist = Math.hypot(player.x - enemy.x, player.y - enemy.y);
                    
                    if (dist < player.attackRange + enemy.radius) {
                        const isCritical = Math.random() < 0.2;
                        const damage = isCritical ? player.attackDamage * 2 : player.attackDamage;
                        
                        enemy.health -= damage;
                        createDamageText(enemy.x, enemy.y - 30, damage, isCritical);
                        attacked = true;
                        
                        if (isCritical) {
                            soundEffects.crit();
                        } else {
                            soundEffects.hit();
                        }
                    }
                }
                
                if (attacked) {
                    player.attackCooldown = 20;
                    soundEffects.attack();
                }
            }
            
            // Update and draw enemies
            for (let i = enemies.length - 1; i >= 0; i--) {
                const enemy = enemies[i];
                
                // Move toward player (unless stunned)
                if (!enemy.stunned) {
                    const angle = Math.atan2(player.y - enemy.y, player.x - enemy.x);
                    enemy.x += Math.cos(angle) * enemy.speed;
                    enemy.y += Math.sin(angle) * enemy.speed;
                }
                
                // Attack player if close
                const distToPlayer = Math.hypot(player.x - enemy.x, player.y - enemy.y);
                if (distToPlayer < player.radius + enemy.radius && enemy.attackCooldown <= 0) {
                    if (!player.isDodging) {
                        player.health -= enemy.damage;
                        createDamageText(player.x, player.y - 30, enemy.damage);
                    }
                    enemy.attackCooldown = 60;
                }
                
                if (enemy.attackCooldown > 0) {
                    enemy.attackCooldown--;
                }
                
                // Check if enemy died
                if (enemy.health <= 0) {
                    spawnGold(enemy.x, enemy.y, enemy.gold);
                    score += enemy.score;
                    enemiesKilled++;

                    // === KILLS TRACKING ===
                    if (!user.kills) user.kills = 0;
                    user.kills += 1;
                    users[currentUser] = user;
                    localStorage.setItem('realmz-users', JSON.stringify(users));

                    // === QUEST PROGRESS TRACKING ===
                    if (enemy.type === 'goblin') updateQuestProgress('kill_goblins');
                    if (enemy.type === 'elite') updateQuestProgress('kill_elites');
                    if (enemy.type === 'boss') updateQuestProgress('weekly_boss');

                    // === LEVELING SYSTEM ===
                    if (!user.level) user.level = 1;
                    if (!user.exp) user.exp = 0;
                    const expGain = 10 + (enemy.type === 'elite' ? 25 : 0) + (enemy.type === 'boss' ? 100 : 0);
                    user.exp += expGain;

                    // Level up logic
                    let leveledUp = false;
                    while (user.exp >= getExpToLevel(user.level)) {
                        user.exp -= getExpToLevel(user.level);
                        user.level += 1;
                        leveledUp = true;
                    }
                    users[currentUser] = user;
                    localStorage.setItem('realmz-users', JSON.stringify(users));

                    if (leveledUp) {
                        showLevelUpUI(user.level);
                        playLevelUpSound();
                    }

                    if (enemy.type === 'boss') {
                        bossActive = false;
                        document.getElementById('boss-health').style.display = 'none';
                    }
                    
                    enemies.splice(i, 1);
                    soundEffects.gold();

                    // Item drop chance
                    if (Math.random() < 0.25) { // 25% chance per kill
                        const item = getRandomArenaItem();
                        // --- Add to inventory (persistent) ---
                        user.inventory = user.inventory || [];
                        user.inventory.push({ ...item });
                        // --- Update red dot count (session) ---
                        let newCount = parseInt(sessionStorage.getItem('newInventoryCount') || '0') + 1;
                        sessionStorage.setItem('newInventoryCount', newCount.toString());
                        // --- Save user ---
                        users[currentUser] = user;
                        localStorage.setItem('realmz-users', JSON.stringify(users));
                        // --- Show popup ---
                        showArenaItemPopup(item);
                    }
                }
            }
            
            // Update boss health UI
            if (bossActive) {
                const boss = enemies.find(e => e.type === 'boss');
                if (boss) {
                    const healthPercent = (boss.health / 200) * 100;
                    document.getElementById('boss-health-bar').style.width = `${healthPercent}%`;
                }
            }
            
            // Update gold drops
            for (let i = goldDrops.length - 1; i >= 0; i--) {
                const gold = goldDrops[i];
                gold.sparkleTimer++;
                
                // Check if player collected
                const dist = Math.hypot(player.x - gold.x, player.y - gold.y);
                if (dist < player.radius + gold.radius && !gold.collected) {
                    gold.collected = true;
                    collectedGold += gold.amount;
                    document.getElementById('gold-display').textContent = collectedGold;
                    soundEffects.gold();

                    // === QUEST PROGRESS TRACKING ===
                    updateQuestProgress('collect_gold', gold.amount);
                }
                
                // Remove collected gold
                if (gold.collected) {
                    goldDrops.splice(i, 1);
                }
            }
            
            // Check wave completion
            if (enemiesKilled >= enemiesInWave && enemiesInWave > 0) {
                startWave(currentWave + 1);
            }
            
            // Check player health
            if (player.health <= 0) {
                gameOver(false);
                return;
            }
            
            // Update UI
            const healthPercent = (player.health / player.maxHealth) * 100;
            document.getElementById('health-bar').style.width = `${healthPercent}%`;
            document.getElementById('health-text').textContent = `${Math.floor(player.health)}/${player.maxHealth}`;
            
            document.getElementById('wave-display').textContent = `WAVE: ${currentWave} | ENEMIES: ${enemies.length}`;
            document.getElementById('score-display').textContent = score;
            
            // Draw everything
            drawGame();
            
            // Continue game loop
            requestAnimationFrame(gameLoop);
        }

        function drawGame() {
            // Draw player
            ctx.beginPath();
            ctx.arc(player.x, player.y, player.radius, 0, Math.PI * 2);
            ctx.fillStyle = player.isDodging ? 'rgba(157, 78, 221, 0.5)' : player.color;
            ctx.fill();
            
            // Draw attack range when attacking
            if (mouse.isDown && player.attackCooldown <= 0) {
                ctx.beginPath();
                ctx.arc(player.x, player.y, player.attackRange, 0, Math.PI * 2);
                ctx.strokeStyle = 'rgba(255, 255, 255, 0.3)';
                ctx.lineWidth = 2;
                ctx.stroke();
            }
            
            // Draw enemies
            enemies.forEach(enemy => {
                // Enemy body
                ctx.beginPath();
                ctx.arc(enemy.x, enemy.y, enemy.radius, 0, Math.PI * 2);
                ctx.fillStyle = enemy.color;
                ctx.fill();
                
                // Enemy health bar
                const healthPercent = (enemy.health / (enemy.type === 'boss' ? 200 : enemy.type === 'elite' ? 50 : 30)) * 100;
                const barWidth = enemy.radius * 2;
                const barHeight = 5;
                
                ctx.fillStyle = 'rgba(0, 0, 0, 0.5)';
                ctx.fillRect(enemy.x - enemy.radius, enemy.y - enemy.radius - 10, barWidth, barHeight);
                
                ctx.fillStyle = healthPercent > 50 ? '#55ff55' : healthPercent > 20 ? '#ffff55' : '#ff5555';
                ctx.fillRect(enemy.x - enemy.radius, enemy.y - enemy.radius - 10, barWidth * (healthPercent / 100), barHeight);
            });
            
            // Draw gold drops
            goldDrops.forEach(gold => {
                ctx.beginPath();
                ctx.arc(gold.x, gold.y, gold.radius, 0, Math.PI * 2);
                ctx.fillStyle = gold.color;
                ctx.fill();
                
                // Sparkle effect
                if (gold.sparkleTimer % 10 === 0) {
                    ctx.beginPath();
                    ctx.arc(
                        gold.x + (Math.random() * 10 - 5),
                        gold.y + (Math.random() * 10 - 5),
                        Math.random() * 3,
                        0,
                        Math.PI * 2
                    );
                    ctx.fillStyle = 'white';
                    ctx.fill();
                }
            });
        }

        // ===== QUEST PROGRESS FUNCTION (stub, implement as needed) =====
        function updateQuestProgress(questId, amount = 1) {
            if (!user.quests || !user.quests.active) return;
            const quest = user.quests.active.find(q => q.id === questId);
            if (quest) {
                quest.progress = (quest.progress || 0) + amount;
                localStorage.setItem('realmz-users', JSON.stringify(users));
            }
        }

        // ===== EVENT LISTENERS ===== //
        document.getElementById('resume-btn').addEventListener('click', togglePause);
        document.getElementById('restart-btn').addEventListener('click', () => {
            window.location.href = 'arena.html';
        });
        document.getElementById('quit-btn').addEventListener('click', () => {
            window.location.href = 'hub.html';
        });

        // ===== APPLY EQUIPMENT BONUSES ===== //
        if (user.equipped && user.equipped.weapon === 'rusty_sword') player.attackDamage += 2;
        if (user.equipped && user.equipped.weapon === 'steel_sword') player.attackDamage += 5;
        if (user.equipped && user.equipped.weapon === 'dragon_blade') player.attackDamage += 10;

        if (user.equipped && user.equipped.armor === 'leather_armor') {
            player.maxHealth += 20;
            player.defense += 3;
        }
        if (user.equipped && user.equipped.armor === 'plate_armor') {
            player.maxHealth += 50;
            player.defense += 5;
        }
        player.health = player.maxHealth;

        // ===== START GAME ===== //
        startWave(1);
        gameLoop();

        // Resize handler
        window.addEventListener('resize', () => {
            canvas.width = window.innerWidth;
            canvas.height = window.innerHeight;
        });

        function getExpToLevel(level) {
            // Example: exponential growth
            return 100 + (level - 1) * 50;
        }

        function showLevelUpUI(level) {
            let overlay = document.getElementById('levelup-overlay');
            if (!overlay) {
                overlay = document.createElement('div');
                overlay.id = 'levelup-overlay';
                overlay.style.position = 'fixed';
                overlay.style.top = 0;
                overlay.style.left = 0;
                overlay.style.width = '100vw';
                overlay.style.height = '100vh';
                overlay.style.display = 'flex';
                overlay.style.justifyContent = 'center';
                overlay.style.alignItems = 'center';
                overlay.style.zIndex = 9999;
                overlay.style.pointerEvents = 'none';
                document.body.appendChild(overlay);
            }
            overlay.innerHTML = `
                <div style="
                    background: rgba(20,10,40,0.95);
                    border: 4px solid #ffd700;
                    border-radius: 20px;
                    padding: 40px 60px;
                    box-shadow: 0 0 40px #ffd70099, 0 0 80px #9d4edd99;
                    text-align: center;
                    animation: pop-in 0.7s cubic-bezier(.68,-0.55,.27,1.55);
                ">
                    <div style="font-size:2.5rem; color:#ffd700; text-shadow:0 0 20px #ffd700;">LEVEL UP!</div>
                    <div style="font-size:1.5rem; color:#fff; margin-top:10px; letter-spacing:2px;">
                        You reached <span style="color:#ffd700; font-size:2.2rem;">LEVEL ${level}</span>
                    </div>
                    <div style="margin-top:20px;">
                        <span style="font-size:2.5rem; color:#ffd700;">‚òÖ</span>
                    </div>
                </div>
                <style>
                @keyframes pop-in {
                    0% { transform: scale(0.7); opacity: 0; }
                    60% { transform: scale(1.1); opacity: 1; }
                    100% { transform: scale(1); }
                }
                </style>
            `;
            overlay.style.opacity = '1';
            setTimeout(() => {
                overlay.style.transition = 'opacity 0.7s';
                overlay.style.opacity = '0';
                setTimeout(() => { if (overlay) overlay.remove(); }, 700);
            }, 2000);
        }

        function playLevelUpSound() {
            try {
                const ctx = new (window.AudioContext || window.webkitAudioContext)();
                const o = ctx.createOscillator();
                const g = ctx.createGain();
                o.type = 'triangle';
                o.frequency.setValueAtTime(440, ctx.currentTime);
                o.frequency.linearRampToValueAtTime(880, ctx.currentTime + 0.25);
                o.frequency.linearRampToValueAtTime(1320, ctx.currentTime + 0.5);
                g.gain.setValueAtTime(0.2, ctx.currentTime);
                g.gain.linearRampToValueAtTime(0, ctx.currentTime + 0.6);
                o.connect(g).connect(ctx.destination);
                o.start();
                o.stop(ctx.currentTime + 0.6);
            } catch (e) {}
        }

        const arenaItemPool = [
            // Common
            { id: 'rusty_sword', name: 'Rusty Sword', type: 'weapon', attack: 2, crit: 0, icon: 'üó°Ô∏è', rarity: 'common', weight: 50 },
            { id: 'cloth_armor', name: 'Cloth Armor', type: 'armor', defense: 1, hp: 0, icon: 'üßµ', rarity: 'common', weight: 50 },
            { id: 'health_potion', name: 'Health Potion', type: 'consumable', effect: 'Restores 50 HP', icon: '‚ù§Ô∏è', rarity: 'common', weight: 60 },
            // Uncommon
            { id: 'steel_sword', name: 'Steel Sword', type: 'weapon', attack: 5, crit: 5, icon: '‚öîÔ∏è', rarity: 'uncommon', weight: 25 },
            { id: 'leather_armor', name: 'Leather Armor', type: 'armor', defense: 3, hp: 20, icon: 'üß•', rarity: 'uncommon', weight: 25 },
            { id: 'greater_potion', name: 'Greater Potion', type: 'consumable', effect: 'Restores 100 HP', icon: 'üíñ', rarity: 'uncommon', weight: 20 },
            // Rare
            { id: 'dragon_blade', name: 'Dragon Blade', type: 'weapon', attack: 10, crit: 10, icon: 'üî•', rarity: 'rare', weight: 8 },
            { id: 'plate_armor', name: 'Plate Armor', type: 'armor', defense: 5, hp: 50, icon: 'üõ°Ô∏è', rarity: 'rare', weight: 8 },
            { id: 'rage_potion', name: 'Rage Potion', type: 'consumable', effect: '+50% Damage (30s)', icon: 'üí¢', rarity: 'rare', weight: 7 },
            // Epic
            { id: 'vorpal_axe', name: 'Vorpal Axe', type: 'weapon', attack: 15, crit: 15, icon: 'ü™ì', rarity: 'epic', weight: 2 },
            { id: 'dragon_scale', name: 'Dragon Scale', type: 'armor', defense: 8, hp: 80, icon: 'üêâ', rarity: 'epic', weight: 2 },
            // Legendary
            { id: 'phoenix_blade', name: 'Phoenix Blade', type: 'weapon', attack: 30, crit: 30, icon: 'ü¶Ö', rarity: 'legendary', weight: 0.5 },
            // ...add more items as you wish!
        ];

        function getRandomArenaItem() {
            const totalWeight = arenaItemPool.reduce((sum, item) => sum + item.weight, 0);
            let rand = Math.random() * totalWeight;
            for (const item of arenaItemPool) {
                if (rand < item.weight) return item;
                rand -= item.weight;
            }
            return arenaItemPool[0];
        }

        function showArenaItemPopup(item) {
            let popup = document.getElementById('arena-item-popup');
            if (!popup) {
                popup = document.createElement('div');
                popup.id = 'arena-item-popup';
                popup.style.position = 'fixed';
                popup.style.left = '40px';
                popup.style.top = '35%';
                popup.style.transform = 'translateY(-10%)';
                popup.style.minWidth = '180px';
                popup.style.maxWidth = '320px';
                popup.style.background = 'rgba(24,16,40,0.98)';
                popup.style.color = '#fff';
                popup.style.fontFamily = "'Press Start 2P', cursive";
                popup.style.fontSize = '0.95rem';
                popup.style.padding = '14px 22px 14px 22px';
                popup.style.borderRadius = '18px';
                popup.style.boxShadow = '0 0 32px #000a, 0 0 80px #0004';
                popup.style.zIndex = 9999;
                popup.style.opacity = 0;
                popup.style.transition = 'opacity 0.5s, transform 0.5s';
                popup.style.pointerEvents = 'none';
                popup.style.textAlign = 'center';
                popup.style.border = '4px solid #fff';
                popup.style.overflow = 'visible';
                document.body.appendChild(popup);
            } else {
                popup.style.left = '40px';
                popup.style.right = '';
                popup.style.top = '35%';
                popup.style.transform = 'translateY(-10%)';
            }

            // Animation and color by rarity
            const rarity = item.rarity || 'common';
            const rarityColors = {
                common: '#cccccc',
                uncommon: '#55ff55',
                rare: '#55aaff',
                epic: '#c155ff',
                legendary: '#ffd700'
            };
            const glowColors = {
                common: '#fff2',
                uncommon: '#55ff5577',
                rare: '#55aaffbb',
                epic: '#c155ffcc',
                legendary: '#ffd700ee'
            };
            const borderColors = {
                common: '#444',
                uncommon: '#55ff55',
                rare: '#55aaff',
                epic: '#c155ff',
                legendary: '#ffd700'
            };

            popup.style.border = `4px solid ${borderColors[rarity] || '#fff'}`;
            popup.style.boxShadow = `
                0 0 32px ${glowColors[rarity] || '#fff2'},
                0 0 80px ${glowColors[rarity] || '#fff2'},
                0 0 0 8px ${glowColors[rarity] || '#fff0'}
            `;
            popup.style.background = `linear-gradient(120deg, ${glowColors[rarity] || '#fff2'} 0%, rgba(24,16,40,0.98) 80%)`;

            // Add animated effects for rarities
            let effectHTML = '';
            if (rarity === 'rare' || rarity === 'epic' || rarity === 'legendary') {
                effectHTML = `<span class="popup-sparkle" style="position:absolute;top:-18px;left:50%;transform:translateX(-50%);font-size:2rem;animation:sparkle 1.2s infinite;">‚ú®</span>`;
            }

            popup.innerHTML = `
                <div style="position:relative;">
                    ${effectHTML}
                    <div style="font-size:2.2rem;margin-bottom:8px;">${item.icon || '‚ùì'}</div>
                    <div style="font-weight:bold;font-size:1.1rem;color:${rarityColors[rarity]};margin-bottom:2px;">
                        ${item.name}
                    </div>
                    <div style="font-size:0.95rem;color:#fff;margin-bottom:4px;">
                        ${item.type ? `[${item.type.toUpperCase()}]` : ''}
                    </div>
                    <div style="font-size:0.95rem;display:block;margin-top:4px;color:${rarityColors[rarity]};letter-spacing:1px;text-shadow:0 0 8px ${glowColors[rarity]};">
                        [${rarity.toUpperCase()}]
                    </div>
                </div>
                <style>
                @keyframes sparkle {
                    0%,100% { opacity: 0.7; transform: translateX(-50%) scale(1);}
                    50% { opacity: 1; transform: translateX(-50%) scale(1.3);}
                }
                </style>
            `;

            popup.style.opacity = 1;
            popup.style.transform = 'scale(1.08)';
            setTimeout(() => {
                popup.style.opacity = 0;
                popup.style.transform = 'scale(0.95)';
            }, 2100);

            // Play sound based on rarity
            playRareItemSound(rarity);
        }

        function playRareItemSound(rarity) {
            try {
                const ctx = new (window.AudioContext || window.webkitAudioContext)();
                const o = ctx.createOscillator();
                const g = ctx.createGain();
                o.type = 'triangle';
                let base = 660;
                if (rarity === 'legendary') {
                    o.frequency.setValueAtTime(base, ctx.currentTime);
                    o.frequency.linearRampToValueAtTime(base * 2, ctx.currentTime + 0.18);
                    o.frequency.linearRampToValueAtTime(base * 3, ctx.currentTime + 0.4);
                    g.gain.setValueAtTime(0.32, ctx.currentTime);
                    g.gain.linearRampToValueAtTime(0, ctx.currentTime + 1.1);
                    o.connect(g).connect(ctx.destination);
                    o.start();
                    o.stop(ctx.currentTime + 1.1);
                } else if (rarity === 'epic') {
                    o.frequency.setValueAtTime(base, ctx.currentTime);
                    o.frequency.linearRampToValueAtTime(base * 1.7, ctx.currentTime + 0.18);
                    g.gain.setValueAtTime(0.22, ctx.currentTime);
                    g.gain.linearRampToValueAtTime(0, ctx.currentTime + 0.7);
                    o.connect(g).connect(ctx.destination);
                    o.start();
                    o.stop(ctx.currentTime + 0.7);
                } else if (rarity === 'rare') {
                    o.frequency.setValueAtTime(base, ctx.currentTime);
                    o.frequency.linearRampToValueAtTime(base * 1.3, ctx.currentTime + 0.12);
                    g.gain.setValueAtTime(0.15, ctx.currentTime);
                    g.gain.linearRampToValueAtTime(0, ctx.currentTime + 0.38);
                    o.connect(g).connect(ctx.destination);
                    o.start();
                    o.stop(ctx.currentTime + 0.38);
                } else if (rarity === 'uncommon') {
                    o.frequency.setValueAtTime(550, ctx.currentTime);
                    g.gain.setValueAtTime(0.11, ctx.currentTime);
                    g.gain.linearRampToValueAtTime(0, ctx.currentTime + 0.22);
                    o.connect(g).connect(ctx.destination);
                    o.start();
                    o.stop(ctx.currentTime + 0.22);
                } 
            } catch (e) {
                // Handle audio errors silently
            }
        }
        </script>
        <style>
        .arena-player {
    position: absolute;
    width: 60px;
    height: 80px;
    display: flex;
    flex-direction: column;
    align-items: center;
}
.player-name {
    font-size: 0.9rem;
    margin-bottom: 2px;
}
.player-sprite {
    width: 48px;
    height: 48px;
    background: #222;
    border-radius: 50%;
    border: 2px solid #9d4edd;
}
        </style>
    </body>
</html>
